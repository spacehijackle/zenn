---
title: "Swing 宣言的UI化計画⑤ ～変数の変化をトリガーに画面更新に挑戦！～"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "Java", "Swing", "GUI", "宣言的UI", "実験" ]
published: false
---

## 遂に来た！データ・バインディングぅ👍

`SwiftUI`と言えば、宣言的UIによる画面構築と共に、UIに紐づいた変数値の変化に合わせて対象のUIを自動的に更新する、という便利な機能があります。例えば以下のようなモノです。

```Swift
struct CounterView: View
{
    // カウント変数
    @State private var counter = 0

    var body: some View
    {
        VStack
        {
            // カウント変数表示
            Text("\(counter)")

            Button("Push to Increment")
            {
                // ボタン押下でカウントアップ(+1)
                counter = count + 1
            }
        }
    }
}
```
ボタンを押すと`counter`変数が +1 され、それと共に`counter`変数を表示しているテキストも自動的に更新されます。今回は、この自動的に更新する仕組みに挑戦！ということなんです。

ところで、同じ宣言的UIを採用しているフレームワークでも、`Flutter`の場合、同等の仕組みはありません。UIと変数を紐づけても自動更新はないので、自分で画面更新の命令を実行するか、もしくは`Riverpod`というプラグインを導入し自動化を行います。ただし、`Riverpod`は単方向データ・バインディングであり、`SwiftUI`の双方向のそれと比べ、かなり煩雑な処理記述が必要になります。ここでは具体的な処理は示しませんが`Riverpod`の場合、`ViewModel`の変数変化を`View`側に落とし込むための記述が`View`に必要となり、ただでさえインデントが多い`Flutter`の`View`において、かなりの見づらさではあります… 🥲

ちなみに、なぜ煩雑な単方向を採用するのか？という疑問に対し、データの流れが一方向なのでデバッグし易い、というのが良く目にする理由です。ただ双方向の場合、一方向はフレームワークが担っているため、バグが生じたとしても、デバッグで追っていくのは実質一方向です。なので私としては単方向を採用する理由は「？」なんです…

と、言うことで`SwingUI`では双方向を採用します（なお、`ViewModel`の話をしていましたが、しばらくは`View`のみのサンプル・プログラムの予定です）。ちなみに私が考える双方向のデメリットは、UIに紐づける変数を`View`からも`ViewModel`からも変更可能（アクセス制御）にする必要があるため、本来`ViewModel`側で記述するロジックを`View`側でも記述できてしまう、という点でしょうか。つまり **`View`にロジックを組んでしまう不届き者を発生させるリスクがどうしても生じてしまう** ことだと考えています。


## まずはカウンターアプリから

先ほど`SwiftUI`の例でカウンターの例を示しましたが、これと同様のプログラムを`SwingUI`で書いてみました。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/counter/CounterView.java

![](/images/articles/9b334991d26717/counter01.jpg =180x)

肝心な`counter`変数ですが、以下のように宣言しています。

```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

`UIValue`は監視対象とする変数のハコのような存在です。変数自体がハコで例えられるので、ハコのハコ、みたいになって少々紛らわしいですね。本来は普通のカウント変数に`SwiftUI`のようにアノテーションを付加すると、コンパイル時に裏でコードを自動生成しようと考えていましたが…

```Java
@State
private int counter = 0;
```
↓自動的にコード書き換え！
```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

AIエージェントがその実現に難色を示すんで諦めました。まぁ外部ライブラリ等の力を借りない限り、ムリっぽいのは確からしいようなので、ここは仕方なく… ということです。

さて、それでは`UIValue`について説明していきます。以下にソースを載せますが、全てを解説するのは大変なので、重要な点に絞って改めて説明します。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/value/UIValue.java

以下、`UIValue`の重要な箇所を抽出してみました。

```Java:UIValue.java
public class UIValue<T>
{
    // 保持する値
    private T value;

    public UIValue(T value)
    {
        this.value = value;
    }

    public T get()
    {
        return this.value;
    }

    public void set(T value)
    {
        // 値の変更がないかチェック
        boolean isNotEquals = !(Objects.equals(this.value, value));
        if(isNotEquals)
        {
            this.value = value;

            // 値の変更を通知
            fireOnValueChanged();
        }
    }
}
```

様々な型の変数に対応するため、ジェネリクスで対応します。カウンターの場合`int`なので`Integer`型で`UIValue`を生成します（コンストラクタ）。これにより、整数型の変数を`UIValue`が保持することになります。

この保持している変数を取り出すには`UIValue#get()`メソッドを、またはこの変数に対し、`UIValue#set(T)`を呼び出すことで、保持している任意型のデータを書き換えます。つまりカウント加算する場合、以下のような記述になります。

```Java:CounterView.java
    // カウントアップ・ボタン
    Button.of("Push to increment")
        .onClicked(self -> counter.set(counter.get() + 1)),
```

`counter#get()`でカウント値を取り出し、それに +1 加算した値を`counter#set(T)`で設定しています。

`UIValue#set(T)`では、保持している値と引数で指定された値を比較し、変化があった場合にリスナーへの通知を行います。もちろん、通知を行う前にリスナーの登録を行う必要があり、そのためのメソッドが`UIValue`に用意されています。

```Java:UIValue.java
    public void addValueChangeListener(ValueChangeListener listener)
    {
        this.listeners.add(listener);
    }
```

なお、このリスナー登録の必要があるのは、各UIコンポーネントなので、プログラマ側が登録する必要はありません。


## UIコンポーネント側を見てみよう！

`Swing`でテキスト表示するには`JLabel`を利用します。この`JLabel`を基にして、これまで同様、`SwingUI`に適応させるため、`Widget`インターフェースを実装した継承クラス`LabelWT`を作成します。以下がそのコードになりますが、改めて重要部分について説明するので、ざっと見る、あるいはスキップしても構いません。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/widget/text/LabelWT.java

それでは、重要な部分に絞って説明します。

```Java:LabelWT.java
public class LabelWT extends JLabel implements Widget<LabelWT>
{
    // 表示テキスト
    private UIValue<T> text;

    // フォント
    private UIValue<Font> font = new UIValue<>(getFont());

    public LabelWT(UIValue<T> text)
    {
        super(text.get().toString());

        this.text = text;
        this.text.addValueChangeListener(() ->
        {
            WidgetHelper.invokeToRefresh(LabelWT.this);
        });
    }

    @Override
    public void refreshWT()
    {
        setText(text.get().toString());

        setFont(font.get());
    }

    public LabelWT<T> font(Font font)
    {
        return font(new UIValue<>(font));
    }

    public LabelWT<T> font(UIValue<Font> font)
    {
        this.font = font;
        this.font.addValueChangeListener(() -> WidgetHelper.invokeToRefresh(LabelWT.this));
        setFont(font.get());
        return this;
    }
}
```

まずコンストラクタですが、任意型を保持する`UIValue<T>`を引数に取ります。テキスト表示なので`UIValue<String>`じゃないか？、と思われる方もおられるでしょう。まぁそうですね。それでも良いと思います。とりあえず何の型であっても、そのクラスで`Object#toString()`が定義されていたら、それを表示対象とする、という方針で任意の型に対応することを決めました。

ということで、親の`JLabel`のコンストラクタ引数に渡すのは、`UIValue`が保持する任意型クラスの`Object#toString()`になります。これで画面表示するテキストは決定です。そして、その後の処理が大事なのですが…

```Java:LabelWT.java
    this.text = text;
    this.text.addValueChangeListener(() ->
    {
        WidgetHelper.invokeToRefresh(LabelWT.this);
    });
```

コンストラクタに指定された`UIValue`を保持した後、変更リスナーを登録します。これで、もし`UIValue`が保持する値に変更があった場合、画面更新処理が走るよう設定しておきます。その画面更新処理を見てみましょう。

```Java:WidgetHelper.java
public class WidgetHelper
{
    /**
     * ウィジェットが属するフレームまで遡り、下位コンポーネント全体の更新を行う。
     */
    public static <T extends JComponent> void invokeToRefresh(Widget<T> widget)
    {
        Window w = SwingUtilities.getWindowAncestor((JComponent)widget);
        if(w != null)
        {
            if(w instanceof Framer)
            {
                ((Framer)w).refreshWT();
            }
        }
    }
}
```

ここでの処理は引数に指定されたウィジェット、つまりここで言う所の`LabelWT`になりますが、これが配置されているフレーム`Framer`（ウィンドウ・フレーム）を取得し、その`refreshWT()`を呼び出します。

```Java:Framer.java
    /**
     * 下位コンポーネントの更新処理を行う。
     */
    public void refreshWT()
    {
        for(Component c : getContentPane().getComponents())
        {
            //↓下位コンポーネントの更新をUIスレッド上で実行
            //refresh(c);
            SwingUtilities.invokeLater(() -> refresh(c));
        }
    }

    /**
     * 下位コンポーネントの更新処理を再帰的に行う。
     * 
     * @param c コンポーネント
     */
    private void refresh(Component c)
    {
        if(c instanceof JComponent)
        {
            for(Component child : ((JComponent)c).getComponents())
            {
                if(child instanceof Widget<?>)
                {
                    ((Widget<?>)child).refreshWT();
                }

                refresh(child);
            }
        }
    }
```

`Framer#refreshWT()`でやっていることは、フレームに配置されたコンポーネントを一つ一つ取り出し、そのコンポーネントが`Widget`インターフェースを実装していれば、そのインターフェースで定義されている`void refreshWT()`を呼び出す、ということです。

なので話を戻すと、`LabelWT`で保持している`UIValue`のテキスト内容に変化があれば、最終的に`LabelWT#refreshWT()`が呼び出される、ということになります。

```Java:LabelWT.java
    @Override
    public void refreshWT()
    {
        setText(text.get().toString());
        setFont(font.get());
    }
```

改めて`LabelWT#refreshWT()`を見てみると、まず保持している`UIValue`のテキストを取り直し、それを表示テキストとして設定し直しています。また、フォントについても同様に保持しているフォント（これも`UIValue`で保持）を設定し直しています。なお、フォントについては初期値はデフォルトのフォントであり、変更する場合は、同クラスの`LabelWT#font(Font)`、もしくは`LabelWT#font(UIValue<Font>)`で指定可能です。

この一連の処理により`counter`変数が書き換えられると、表示されたカウント文字列が自動的に書き換わる処理が実現されています。これは`SwingUI`を実現する上で重要な仕組みのひとつです。`SwiftUI`では同様の仕組みをコードを自動生成する等して、値の監視＆UIの更新を行っているようですが、`SwingUI`では簡易的ではありますが、このような処理で実現しています。

ちなみに、この仕組みで実現しそうな気はしていましたが、実際に実現した時は少し驚きでした。思ったよりもあっけなかったんでね。仮にこの仕組みが上手くいかなければ、この記事を書くこともなかったでしょうし、記事を書く時間を別な有益な作業に割り振れたんじゃないか、とも思い、今は複雑な気持ちではあります。。。一応、公開する価値がある、との思いで記事化しましたが、くじけそうになった時に`Copilot`に記事内容を褒められ、その価値は高いよ、と言われたのでモチベーションを保っています。果たして`Copilot`の評価は正しかったのか、そうでなかったのか… いずれ分かるでしょう🤗

さて、テキストコンポーネント`LabelWT`の説明が終わりましたので、次はその`LabelWT`を呼び出す`Text`の実装です。

`Text`は`SwingUI`でテキスト表示を呼び出す時に利用するクラスですが…

```Java:CounterView.java
    // カウント表示
    Text.of(counter)
        .font(new Font("Dialog", Font.BOLD, 48)),
```

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/front/text/Text.java

その中身は基本的に`LabelWT`を呼び出すだけです。このテキスト表示コンポーネントは表示領域の横幅が自動的に調整されますが、もし`Widget.frame()`で横幅を指定した場合、テキストの位置を左寄せ（デフォルト）、あるいは中央、右寄せ、と指定できるよう、位置指定も可能になっています。


## お次は名言表示アプリ！

これからはしばらく遊んでみたいと思います。