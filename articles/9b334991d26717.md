---
title: "Swing 宣言的UI化計画⑤ ～変数の変化をトリガーに画面更新に挑戦！～"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "Java", "Swing", "GUI", "宣言的UI", "実験" ]
published: true
---

## 遂に来た！データ・バインディングぅ👍

`SwiftUI`と言えば、宣言的UIによる画面構築と共に、UIに紐づいた変数値の変化に合わせて対象のUIを自動的に更新する、という便利な機能があります。例えば以下のようなモノです。

```Swift
struct CounterView: View
{
    // カウント変数
    @State private var counter = 0

    var body: some View
    {
        VStack
        {
            // カウント変数表示
            Text("\(counter)")

            Button("Push to Increment")
            {
                // ボタン押下でカウントアップ(+1)
                counter = count + 1
            }
        }
    }
}
```
ボタンを押すと`counter`変数が +1 され、それと共に`counter`変数を表示しているテキストも自動的に更新されます。今回は、この自動的に更新する仕組みに挑戦！ということなんです。

ところで、同じ宣言的UIを採用しているフレームワークでも、`Flutter`の場合、同等の仕組みはありません。UIと変数を紐づけても自動更新はないので、自分で画面更新の命令を実行するか、もしくは`Riverpod`というプラグインを導入し自動化を行います。ただし`Riverpod`は単方向データ・バインディングであり、`SwiftUI`の双方向のそれと比べ、かなり煩雑な処理記述が必要になります。ここでは具体的な処理は示しませんが`Riverpod`の場合、`ViewModel`での変数変化を`View`側に反映させるための記述が`View`に必要となり、ただでさえインデントが多い`Flutter`の`View`記述において、かなりの見づらさではあります…🥲

:::message
宣言的UIにおける単方向, 双方向データ・バインディングについて知りたい方は検索して調べてみてください。
:::

ちなみに、なぜ煩雑な単方向を採用するのか？という疑問に対し、データの流れが一方向なのでデバッグし易い、というのが良く目にする理由です。ただ双方向の場合、一方向（`View`→`ViewModel`）はフレームワークが担っているため、バグ（プログラマ由来）が生じたとしても、デバッグで追っていくのは実質一方向です。なので私としては単方向を採用する理由は「？」なんです… 単方向の方がパフォーマンス面で有利、とも聞きますが、`SwiftUI`でパフォーマンスが特別悪いとの評判はないと思います。

と、言うことで`SwingUI`では双方向を採用します（なお、`ViewModel`の話をしていましたが、しばらくは`View`のみのサンプル・プログラムの予定です）。ちなみに私が考える双方向のデメリットは、UIに紐づける変数を`View`からも`ViewModel`からも変更可能（アクセス制御の話）にする必要があるため、本来`ViewModel`側で記述するロジックを`View`側でも記述できてしまう、という点でしょうか。つまり **`View`にロジックを組んでしまう不届き者を発生させるリスクがどうしても生じてしまう** ことだと考えています。


## まずはカウンターアプリから

先ほど`SwiftUI`の例でカウンターの例を示しましたが、これと同様のプログラムを`SwingUI`で書いてみました。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/counter/CounterView.java

![](/images/articles/9b334991d26717/counter01.jpg =180x)

肝心な`counter`変数ですが、以下のように宣言しています。

```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

`UIValue`は監視対象とする変数のハコのような存在です。変数自体がハコで例えられるので、ハコのハコ、みたいになって少々紛らわしいですね。本来は普通のカウント変数に`SwiftUI`のようにアノテーションを付加すると、コンパイル時に裏でコードを自動生成しようと考えていましたが…

```Java
@State
private int counter = 0;
```
↓自動的にコード書き換え！
```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

AIエージェントがその実現に難色を示すんで諦めました。まぁ外部ライブラリ等の力を借りない限り、ムリっぽいのは確からしいようなので、ここは仕方なく… ということです。

さて、それでは`UIValue`について説明していきます。以下にソースを載せますが、全てを解説するのは大変なので、重要な点に絞って改めて説明します。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/value/UIValue.java

以下、`UIValue`の重要な箇所を抽出してみました。

```Java:UIValue.java
public class UIValue<T>
{
    // 保持する値
    private T value;

    public UIValue(T value)
    {
        this.value = value;
    }

    public T get()
    {
        return this.value;
    }

    public void set(T value)
    {
        // 値の変更がないかチェック
        boolean isNotEquals = !(Objects.equals(this.value, value));
        if(isNotEquals)
        {
            this.value = value;

            // 値の変更を通知
            fireOnValueChanged();
        }
    }
}
```

様々な型の変数に対応するため、ジェネリクスで対応します。カウンターの場合`int`なので`Integer`型で`UIValue`を生成します（コンストラクタ）。これにより、整数型の変数を`UIValue`が保持することになります。

この保持している変数を取り出すには`UIValue#get()`メソッドを、または`UIValue#set(T)`を呼び出すことで、保持している任意型のデータを書き換えます。つまりカウント加算する場合、以下のような記述になります。

```Java:CounterView.java
    // カウントアップ・ボタン
    Button.of("Push to increment")
        .onClicked(self -> counter.set(counter.get() + 1)),
```

`counter#get()`でカウント値を取り出し、それに +1 加算した値を`counter#set(T)`で設定しています。

`UIValue#set(T)`では、保持している値と引数で指定された値を比較し、変化があった場合にリスナーへの通知を行います。もちろん、通知を行う前にリスナーの登録を行う必要があり、そのためのメソッドが`UIValue`に用意されています。

```Java:UIValue.java
    public void addValueChangeListener(ValueChangeListener listener)
    {
        this.listeners.add(listener);
    }
```

なお、このリスナー登録の必要があるのは、各UIコンポーネントなので、プログラマ側が登録する必要はありません。


## UIコンポーネント側を見てみよう！

`Swing`でテキスト表示するには`JLabel`を利用します。この`JLabel`を基にして、これまで同様、`SwingUI`に適応させるため、`Widget`インターフェースを実装した継承クラス`LabelWT`を作成します。以下がそのコードになりますが、改めて重要部分について説明するので、ざっと見る、あるいはスキップしても構いません。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/widget/text/LabelWT.java

それでは、重要な部分に絞って説明します。

```Java:LabelWT.java
public class LabelWT extends JLabel implements Widget<LabelWT>
{
    // 表示テキスト
    private UIValue<T> text;

    // フォント
    private UIValue<Font> font = new UIValue<>(getFont());

    public LabelWT(UIValue<T> text)
    {
        super(text.get().toString());

        this.text = text;
        this.text.addValueChangeListener(() ->
        {
            WidgetHelper.invokeToRefresh(LabelWT.this);
        });
    }

    @Override
    public void refreshWT()
    {
        setText(text.get().toString());
        setFont(font.get());
    }

    public LabelWT<T> font(Font font)
    {
        return font(new UIValue<>(font));
    }

    public LabelWT<T> font(UIValue<Font> font)
    {
        this.font = font;
        this.font.addValueChangeListener(() -> WidgetHelper.invokeToRefresh(LabelWT.this));
        setFont(font.get());
        return this;
    }
}
```

まずコンストラクタですが、任意型を保持する`UIValue<T>`を引数に取ります。テキスト表示なので`UIValue<String>`じゃないか？、と思われる方もおられるでしょう。まぁそうですね。それでも良いと思います。とりあえず何の型であっても、そのクラスの`Object#toString()`の実装をそのまま表示対象とする、という方針で任意の型に対応することに決めました。

ということで、親の`JLabel`のコンストラクタ引数に渡すのは、`UIValue`が保持する任意型クラスの`Object#toString()`になります。これで画面表示するテキストは決定です。そして、その直後の処理が大事なのですが…

```Java:LabelWT.java
    this.text = text;
    this.text.addValueChangeListener(() ->
    {
        WidgetHelper.invokeToRefresh(LabelWT.this);
    });
```

コンストラクタに指定された`UIValue`を保持した後、変更リスナーを登録します。これで、もし`UIValue`が保持する値に変更があった場合、画面更新処理が走るよう設定しておきます。それでは、その画面更新処理を見てみましょう。

```Java:WidgetHelper.java
public class WidgetHelper
{
    /**
     * ウィジェットが属するフレームまで遡り、下位コンポーネント全体の更新を行う。
     */
    public static <T extends JComponent> void invokeToRefresh(Widget<T> widget)
    {
        Window w = SwingUtilities.getWindowAncestor((JComponent)widget);
        if(w != null)
        {
            if(w instanceof Framer)
            {
                ((Framer)w).refreshWT();
            }
        }
    }
}
```

ここでの処理は引数に指定されたウィジェット、つまりここで言う所の`LabelWT`になりますが、これが配置されているフレーム`Framer`（ウィンドウ・フレーム）を取得し、その`refreshWT()`を呼び出します。

```Java:Framer.java
    /**
     * 下位コンポーネントの更新処理を行う。
     */
    public void refreshWT()
    {
        for(Component c : getContentPane().getComponents())
        {
            //↓下位コンポーネントの更新をUIスレッド上で実行
            //refresh(c);
            SwingUtilities.invokeLater(() -> refresh(c));
        }
    }

    /**
     * 下位コンポーネントの更新処理を再帰的に行う。
     * 
     * @param c コンポーネント
     */
    private void refresh(Component c)
    {
        if(c instanceof JComponent)
        {
            for(Component child : ((JComponent)c).getComponents())
            {
                if(child instanceof Widget<?>)
                {
                    ((Widget<?>)child).refreshWT();
                }

                refresh(child);
            }
        }
    }
```

`Framer#refreshWT()`でやっていることは、フレームに配置されたコンポーネントを一つ一つ取り出し、そのコンポーネントが`Widget`インターフェースを実装していれば、そのインターフェースで定義されている`void refreshWT()`を呼び出す、ということです。

なので話を戻すと、`LabelWT`で保持している`UIValue`のテキスト内容に変化があれば、最終的に`LabelWT#refreshWT()`が呼び出される、ということになります。

```Java:LabelWT.java
    @Override
    public void refreshWT()
    {
        setText(text.get().toString());
        setFont(font.get());
    }
```

改めて`LabelWT#refreshWT()`を見てみると、まず保持している`UIValue`のテキストを取り直し、それを表示テキストとして設定し直しています。また、フォントについても同様に保持しているフォント（これも`UIValue`で保持）を設定し直しています。なお、フォントについては初期値はデフォルトのフォントであり、変更する場合は、同クラスの`LabelWT#font(Font)`、もしくは`LabelWT#font(UIValue<Font>)`で指定可能です。

この一連の処理により`counter`変数が書き換えられると、表示されたカウント文字列が自動的に書き換わる処理が実現されています。これは`SwingUI`を実現する上で重要な仕組みのひとつです。`SwiftUI`では同様の仕組みをコードを自動生成する等して、値の監視＆UIの更新を行っているようですが、`SwingUI`では簡易的ではありますが、このような処理で実現しています。

ちなみに、この仕組みで実現しそうな気はしていましたが、実際に実現した時は少し驚きでした。思ったよりもあっけなかったんでね。仮にこの仕組みが上手くいかなければ、この記事を書くこともなかったでしょうし、記事を書く時間を別な有益な作業に割り振れたんじゃないか、とも思え、今は複雑な気持ちではあります。。。一応、公開する価値がある、との思いで記事化しましたが、くじけそうになった時に`Copilot`に記事内容を褒められ、その価値は高いよ、と言われたのでモチベーションを保っています。果たして`Copilot`の評価は正しかったのか、そうでなかったのか… いずれ分かるでしょう🤗

さて、テキストコンポーネント`LabelWT`の説明が終わりましたので、次はその`LabelWT`を呼び出す`Text`の実装です。

`Text`は`SwingUI`でテキスト表示を呼び出す時に利用するクラスですが…

```Java:CounterView.java
    // カウント表示
    Text.of(counter)
        .font(new Font("Dialog", Font.BOLD, 48)),
```

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/front/text/Text.java

中身は基本的に`LabelWT`を呼び出すだけです。このテキスト表示コンポーネントは表示領域の横幅が自動的に調整されますが、もし`Widget.frame()`で横幅を指定した場合、テキストの位置を左寄せ（デフォルト）、あるいは中央、右寄せ、と指定できるよう、位置指定も可能になっています。


## お次は名言表示アプリ！

これからはしばらく遊んでみたいと思います。

![](/images/articles/9b334991d26717/character01.jpg =350x)

各ボタンに割り当てたキャラクターの名言がテキスト表示される、というアプリです。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/phrase/FamousPhrase.java

`phrase`という`UIValue`の変数を用意し、ボタンが押下されると、そのボタンに割り当てられたキャラクターの名言を`phrase`に設定する、という流れです。

```Java:FamousePhrase.java
    Button.of("丹下段平")
        .frame(Width.of(100))
        .onClicked(self -> phrase.set("「立つんだジョー！」")),
```

実際にボタンを押すと…

![](/images/articles/9b334991d26717/character02.jpg =350x)

ってな感じになります。

このフレーズを表示する箇所ですが、以下のようになっています（２つ目の`Text`）。

```Java:FamousePhrase.java
    VStack.of
    (
        UIAlignmentX.Leading,  // 左寄せ

        Spacing.of(4),

        // タイトル
        Text.of("- Famous Phrase -")
            .font(new Font("Dialog", Font.ITALIC, 12)),

        // フレーズ
        Text.of(phrase)
            .font(new Font("Dialog", Font.PLAIN, 24))
            .frame(Width.Infinite, Height.of(80))
            .padding(16)
            .background(Color.white)
    )
    .padding(Horizontal.of(24)),
```

`Text`に`phrase`変数を渡していますね。それからフォント指定とサイズ指定。パディングや背景色の指定もしています。サイズ指定ですが、横幅いっぱいに取るよう`Width.Infinite`で指定しているため、ウィンドウ・フレームいっぱいに広がっています（実際には`Text`を内包する`VStack`にパディング指定しているため、その分の余白が両端に存在）。

ちなみにフレーズが収まり切らない場合は３点リーダが自動的に付加されます。これは`Swing`の`JLabel`元々の機能です。

![](/images/articles/9b334991d26717/character03.jpg =350x)

この状態で横方向にウィンドウを広げると…

![](/images/articles/9b334991d26717/character04.jpg =430x)

隠れていたフレーズがちゃんと表示されました。また白い背景もウィンドウの横幅に合わせて伸びています（実はバグがあったので、`Widget#frame()`の実装を修正しておきました…）。

ちなみに、フレーズ表示周りは別の記述方法も可能なので、例として載せておきます。

```Java
    HStack.of
    (
        Spacer.of(Width.of(24)),

        VStack.of
        (
            UIAlignmentX.Leading,  // 左寄せ

            Spacing.of(4),

            // タイトル
            Text.of("- Famous Phrase -")
                .font(new Font("Dialog", Font.ITALIC, 12)),

            // フレーズ
            Text.of(phrase)
                .font(new Font("Dialog", Font.PLAIN, 24))
                .frame(Width.Infinite, Height.of(80))
                .padding(16)
                .background(Color.white)
        ),

        Spacer.of(Width.of(24))
    ),
```

先の方法は`VStack`にパディング指定して余白を確保していましたが、この例では`VStack`を`HStack`で囲み、「`Spacer`＋フレーズ（`VStack`）＋`Spacer`」という感じで、横並びにしています。このような形でも同じ画面の見た目を実現できます。まぁ、記述量の少ない先の例の方が良いでしょう。


## カーッカッカッカッカッカー

現在、テレ玉で放送中のあの超人で遊んでみましょう。

![](/images/articles/9b334991d26717/facer01.jpg =350x)
![](/images/articles/9b334991d26717/facer02.jpg =350x)
![](/images/articles/9b334991d26717/facer03.jpg =350x)

表情を示したボタン押下で、それに対応した表情に変わります。ちなみに本当は表情テキストをAA（アスキー・アート）にしようと思ったんですが、フォントを色々変えても崩れて見えてしまうので諦めました…

ところでアニメでは表情ごとに別々の声なんですけど、声帯も別々なんでしょうか？？？

ソースは以下です。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/face/FaceChanger.java

`UIValue`の変数が３つありますね。一つは表情用のテキスト。それから文字色と背景色です。ちなみに`UIValue`の生成方法ですが、`UIValue.of(T)`でも可能になっています。

```Java:FaceChanger.java
public class FaceChanger
{
    // 表情テキスト
    private UIValue<String> faceText = UIValue.of(FacialExp.Smile.text);

    // 表情前景色
    private UIValue<Color> faceFgColor = UIValue.of(FacialExp.Smile.fgColor);

    // 表情背景色
    private UIValue<Color> faceBgColor = UIValue.of(FacialExp.Smile.bgColor);
```

これらの値は定数として別クラスに定義してあります。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/face/FacialExp.java

それでは改めて表情テキスト部を見てみましょう。

```Java:FaceChanger.java
    // 表情テキスト
    Text.of(faceText, HorizontalAlignment.Center)
        .frame(Width.of(80), Height.of(80))
        .font(new Font(Font.MONOSPACED, Font.BOLD, 12))
        .foreground(faceFgColor)
        .background(faceBgColor),
```

先に宣言していたそれぞれの変数（表情テキスト, 文字色, 背景色）が指定されていますね。ボタンを押すと、それぞれの変数が書き換わる、という仕掛けです。

```Java:FaceChanger.java
    Button.of("怒り")
        .frame(Width.of(80))
        .onClicked((self) ->
        {
            faceText.set(FacialExp.Angry.text);
            faceFgColor.set(FacialExp.Angry.fgColor);
            faceBgColor.set(FacialExp.Angry.bgColor);
        }),
```

ここで改めて`LabelWT`を見てみると…

```Java:LabelWT.java
    @Override
    public LabelWT<T> background(UIValue<Color> bgColor)
    {
        if(!isOpaque()) setOpaque(true);  // 背景色を表示するために不透明化

        this.bgColor = bgColor;
        this.bgColor.addValueChangeListener(() -> WidgetHelper.invokeToRefresh(LabelWT.this));
        setBackground(bgColor.get());
        return this;
    }

    public LabelWT<T> foreground(UIValue<Color> fgColor)
    {
        this.fgColor = fgColor;
        this.fgColor.addValueChangeListener(() -> WidgetHelper.invokeToRefresh(LabelWT.this));
        setForeground(fgColor.get());
        return this;
    }
```

文字色（前景色）や背景色を設定するメソッドがあります。引数で指定された`UIValue`を受け持ち、テキスト表示の場合と同様、変更リスナーを設定しています。その後で背景色や文字色を設定しています。`background(UIValue<Color>)`の方だけ`@Override`指定されているのは、このメソッドが`Widget`インターフェースで定義されているメソッドだからであり、逆に`foreground(UIValue<Color>)`は自前のメソッドなので`@Override`はありません。

なお`JLabel`はデフォルトで背景色が透明なので、`background(UIValue<Color>)`では不透明にする処理を入れています（JComponent#setOpaquue(boolean)）。

改めて、ですが、これら文字色、背景色設定メソッドでは変更リスナーを設定しているため、ボタンが押下され、`UIValue`の値が変化すると再描画の処理が実行されます。先にも説明した通り、再描画用メソッドが呼び出されます。

```Java:LabelWT.java
    @Override
    public void refreshWT()
    {
        setText(text.get().toString());

        setForeground(fgColor.get());
        setBackground(bgColor.get());
    }
```

表示テキストや色といった、それぞれの変数に設定された値が反映されて画面に表示されます。

実はちょっと気になることがあって、１回のボタン押下につき、３回再描画処理が走るので、パフォーマンス的にどうなのかな？っていう心配があるんですね。将来的に見直す必要があるかもしれません。


## さいごに

今回は`SwingUI`における重要な仕組み、データ・バインディングによる画面再描画の仕組みについて解説しました。実際のところ、各コンポーネントは前景色, 背景色だけでなく、たくさんの設定メソッドを持っているため、それらを全部`UIValue`に対応させるのはかなりの労力です。なので`Java`でも宣言的UIに対応してくれないかなぁー、と常に願っています😅

次回は何をテーマにするか、まだ未定です。しばらく考えてみます。では👋🏻

今回のソース一式は[こちら](https://github.com/spacehijackle/SwingUI_05/tree/main)


## 次回記事
https://zenn.dev/spacehijackle/articles/e4cdef8a322a5b