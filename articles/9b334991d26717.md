---
title: "Swing 宣言的UI化計画⑤ ～変数の変化をトリガーに画面更新に挑戦！～"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "Java", "Swing", "GUI", "宣言的UI", "実験" ]
published: false
---

## 遂に来た！データ・バインディングぅ👍

`SwiftUI`と言えば、宣言的UIによる画面構築と共に、UIに紐づいた変数値の変化に合わせて対象のUIを自動的に更新する、という便利な機能があります。例えば以下のようなモノです。

```Swift
struct CounterView: View
{
    // カウント変数
    @State private var counter = 0

    var body: some View
    {
        VStack
        {
            // カウント変数表示
            Text("\(counter)")

            Button("Push to Increment")
            {
                // ボタン押下でカウントアップ(+1)
                counter += 1
            }
        }
    }
}
```
ボタンを押すと`counter`変数が +1 され、それと共に`counter`変数を表示しているテキストも自動的に更新されます。今回は、この自動的に更新する仕組みに挑戦！ということなんです。

ところで、同じ宣言的UIを採用しているフレームワークでも、`Flutter`の場合、同等の仕組みはありません。UIと変数を紐づけても自動更新はないので、自分で画面更新の命令を実行するか、もしくは`Riverpod`というプラグインを導入し自動化を行います。ただし、`Riverpod`は単方向データ・バインディングであり、`SwiftUI`の双方向のそれと比べ、かなり煩雑な処理記述が必要になります。ここでは具体的な処理は示しませんが`Riverpod`の場合、`ViewModel`の変数変化を`View`側に落とし込むための記述が`View`に必要となり、ただでさえインデントが多い`Flutter`の`View`において、かなりの見づらさではあります… 🥲

ちなみに、なぜ煩雑な単方向を採用するのか？という疑問に対し、データの流れが一方向なのでデバッグし易い、というのが良く目にする理由です。ただ双方向の場合、一方向はフレームワークが担っているため、バグが生じたとしても、デバッグで追っていくのは実質一方向です。なので私としては単方向を採用する理由は「？」なんです…

と、言うことで`SwingUI`では双方向を採用します（なお、`ViewModel`の話をしていましたが、しばらくは`View`のみのサンプル・プログラムの予定です）。ちなみに私が考える双方向のデメリットは、UIに紐づける変数を`View`からも`ViewModel`からも変更可能（アクセス制御）にする必要があるため、本来`ViewModel`側で記述するロジックを`View`側でも記述できてしまう、という点でしょうか。つまり **`View`にロジックを組んでしまう不届き者を発生させるリスクがどうしても生じてしまう** ことだと考えています。


## まずはカウンターアプリから

先ほど`SwiftUI`の例でカウンターの例を示しましたが、これと同様のプログラムを`SwingUI`で書いてみました。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/swingui_05/counter/CounterView.java

肝心な`counter`変数ですが、以下のように宣言しています。

```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

`UIValue`は監視対象とする変数のハコのような存在です。変数自体がハコで例えられるので、ハコのハコ、みたいになって少々紛らわしいですね。本来は普通のカウント変数に`SwiftUI`のようにアノテーションを付加すると、コンパイル時に裏でコードを自動生成しようと考えていましたが…

```Java
@State
private int counter = 0;
```
↓自動的にコード書き換え！
```Java
private UIValue<Integer> counter = new UIValue<>(0);
```

AIエージェントがその実現に難色を示すんで諦めました。まぁ外部ライブラリ等の力を借りない限り、ムリっぽいのは確からしいようなので、ここは潔く… ということです。

さて、それでは`UIValue`について説明していきます。

https://github.com/spacehijackle/SwingUI_05/blob/main/app/src/main/java/com/swingui/value/UIValue.java

全てを解説するのは大変なので、重要な点に絞って説明します。

```Java:UIValue.java
public class UIValue<T>
{
    // 保持する値
    private T value;

    public UIValue(T value)
    {
        this.value = value;
    }

    public T get()
    {
        return this.value;
    }

    public void set(T value)
    {
        // 値の変更がないかチェック
        boolean isNotEquals = !(Objects.equals(this.value, value));
        if(isNotEquals)
        {
            this.value = value;

            // 値の変更を通知
            fireOnValueChanged();
        }
    }
}
```

様々な型の変数に対応するため、ジェネリクスで対応します。カウンターの場合、`int`なので`Integer`型で`UIValue`を生成します。これにより、整数型の変数を`UIValue`が保持することになります。

この保持している変数を取り出すには`UIValue#get()`メソッドを、またはこの変数に対し、`UIValue#set(T)`を呼び出すことで、保持している任意型のデータを書き換えます。つまりカウント加算する場合、以下のような記述になります。

```Java:CounterView.java
    // カウントアップ・ボタン
    Button.of("Push to increment")
        .onClicked(self -> counter.set(counter.get() + 1)),
```

`counter.get()`でカウント値を取り出し、それに +1 加算した値を`counter.set()`で設定しています。当然のことですが、`Swift`の計算プロパティのような書き方は`Java`では不可なので、以下のような書き方はできません…

```Java
    // カウントアップ・ボタン
    Button.of("Push to increment")
        .onClicked(self -> counter = counter + 1),
```

この手の記述を見ると、モダン言語が羨ましくなるんですね～

で、`UIValue#set(T)`では、保持している値と引数で指定された値を比較し、変化があった場合にリスナーへの通知を行います。もちろん、通知を行う前にリスナーの登録を行う必要があり、そのためのメソッドが`UIValue`に用意されています。

```Java:UIValue.java
    public void addValueChangeListener(ValueChangeListener listener)
    {
        this.listeners.add(listener);
    }
```

このリスナー登録の必要があるのは、各UIコンポーネントなので、プログラマ側が登録する必要はありません。


## UIコンポーネント側を見てみよう！

`Swing`でテキスト表示するには`JLabel`を利用します。

