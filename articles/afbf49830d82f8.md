---
title: "Swing 宣言的UI化計画！①"
emoji: "️🚀️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "Java", "Swing", "GUI", "宣言的UI", "実験" ]
published: true
---

## 序章
`Java`の`Swing`が世に登場してから30年近く。既にデスクトップのGUIフレームワークとしてはすっかり影が薄くなってしまいましたが、その惨状は当時熱心に学んだ私からすると、とても寂しいものです。その後、新たなGUIフレームワーク`JavaFX`が登場したものの、これを使ったアプリを見ることはほぼありません。気づけば標準SDKからも外されるという憂き目に合っていて、もはや`Java`のGUIフレームワークが活躍できる場所は皆無、と言っても良いかもしれません（Oracleのインストーラはまだ`Java`なんですかね？）。

そんな状況にある中、私は仕事で宣言的UIである`SwiftUI`に触れ、それまでの命令的UI, もしくは`XML`で組み立てる従来方式からGUI構築が新たな局面に突入したことを実感しました。そこで思い出したのが`Swing`。スペルもめちゃ似てるじゃないですか、`Swift`と。もし`Swing`が宣言的UI化されれば、`JAVAer`の方々も手軽にGUIをいじれるようになるのではないか？と期待するところでしたが、公式からは何のアナウンスもなし。まぁ、冷静に考えて`Java`の文法だと宣言的UI化するのは難しいところもあるのは分かります。なので、この記事では「もしも`Swing`が宣言的UI化されたら？」を実験的に試みようと思います。ただ、私自身はGUI技術の深いところまで精通しているワケではないので、温かい目で見守ってくれたら幸いです🤗

一応、以前の記事のリンクを貼っておきますが、「SwingUI 爆誕！」と題した記事で、簡単なサンプルを載せています。また記事の最後にお手製`SwingUI`で作成したアプリの動画も公開しています。

https://zenn.dev/spacehijackle/articles/2c701299df1fed


## 宣言的UI化するのに必要なこと
世には`Swift`の他にも`Kotlin`や`Flutter(Dart)`でも宣言的UIが採用されていますが、目指すのは`SwiftUI`です。これはデフォルト引数がサポートされていない`Java`では、それが前提の`Kotlin`や`Flutter`のようには記述できない、というのが一番の理由です。ちなみに私は現在`Flutter`でスマホアプリを作っていますが、とにかく色々と面倒なんです。余白を後から追加するのも地味に面倒なんですよね。ツールの機能を使えば良いのですが、ちょっとね…

```Dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp (
      home: Scaffold (
        appBar: AppBar (
          title: Text('Flutter サンプル'),
        ),
        body: Center (
          // Paddingウィジェットで子要素の周囲に余白を設定
          child: Padding (
            padding: EdgeInsets.all(8.0),
            child: Row (  // 垂直方向に並べる
              children: [
                Text (
                  'Flutter Sample',
                  style: TextStyle(fontSize: 18),
                ),
                Column (  // 水平方向に並べる
                  children: [
                    Text("Item1"),
                    Text("Item2"),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
```

やっぱり、このような入れ子構造は見づらいです（何でインデントが2桁なんだ…）。それに子要素に一々`child`や`children`って引数のラベル指定を書かないといけないとか、私にはムダが多いように見えます。本当は`Flutter`で書くのを止めたいくらいなのですが、`Hot Reload`が便利過ぎて… （にしても、末尾の`)`や`]`の連続が気にならなかったの？設計者さん！）

まぁ、いいでしょう。ここでグチることでもありません。一方、`SwiftUI`は以下のような感じです。

```Swift
    var body: some View
    {
        VStack  // 垂直方向に並べる
        {
            Text("SwiftUI Sample")
                .font(.title)
                .padding()  // 周囲に余白

            HStack  // 水平方向に並べる
            {
                Text("Item 1")
                Text("Item 2")
            }
        }
    }
```

`.font()`や`.padding()`は基本的にメソッドチェーンによって実現されています。メソッドチェーンとは`StringBuilder`で見る、アレです。

```Java
StringBuilder sb = new StringBuilder();
sb.append("一行目\n")
  .append("二行目\n")
  .append("三行目\n");
```

`Swing`では基本的にボタン等のGUI部品は`JComponent`という上位クラスを継承していますが、この`JComponent`を各メソッドが返す、という操作を実現します。ちなみに`StringBuilder`は`append(String)`等のメソッドは、自身のクラスのメソッドを連続して呼び出せるよう`StringBuilder`を返却していますが、これと同じ仕組みです。

それと前提として、もちろん`Swing`の基礎知識がある方が良いのですが、まぁとりあえずいいでしょう。必要があれば、都度説明します（たぶん）。


## まずは縦横並びのレイアウトから
基本中の基本、レイアウトから実現していきます。レイアウトとは、GUI部品を並べていくベースとなるもので、`Swing`だと、例えば`FlowLayout`や`BorderLayout`等があります。前者はこのレイアウトを設定した後、ボタン等GUI部品を載せると横並びに並べてくれます（表示しきれなくなったら改行）。後者は中心をメインとし、その周りに上下左右にGUI部品を並べるレイアウトです。

![](https://docs.oracle.com/javase/tutorial/figures/uiswing/layout/BorderLayoutDemo.png =450x)
*Oracleの[BorderLayout説明チュートリアル](https://docs.oracle.com/javase/tutorial/uiswing/layout/border.html)より抜粋*

このようにレイアウトはGUI部品を意図通りに並べるためのベースです。先に挙げた`SwiftUI`の例のように縦並び（垂直方向並び）、横並び（水平方向並び）にするのに適した`Swing`のレイアウトは`BoxLayout`でしょう。

![](https://docs.oracle.com/javase/tutorial/figures/uiswing/layout/BoxLayoutDemo.png =250x)
*Oracleの[BoxLayout説明チュートリアル](https://docs.oracle.com/javase/tutorial/uiswing/layout/box.html)より抜粋*

さて、GUI部品を並べるレイアウトは理解できたとして、それではそのレイアウトをどこに設定するのか？という疑問が生じるでしょう。基本的に`Swing`の作りはウィンドウを表す`JFrame`とその中に配置される`JPanel`が存在します。大枠が`JFrame`で、その中で区画を区切るのが`JPanel`です（`JPanel`自体は単なる背景だけの存在であり、具体的には上図のグレー部分と考えてください）。

上記の`BoxLayout`で例えると、フレーム枠が`JFrame`で、その中が`JPanel`であり、その`JPanel`に`BoxLayout`が設定されることで、ボタンが縦に並んでいる（この例では区画は一つ）、と解釈すれば、とりあえず良いでしょう。ちなみに縦並びの中で横並びを実現するには途中のボタンを`JPanel`に入れ替え（`JPanel`もGUI部品のひとつ）、その`JPanel`（この場合、区画は２つ）に横並びの`BoxLayout`のレイアウトを設定し（下図、黄色部分）、その上にボタンを並べるわけなんですが、イメージできたでしょうか？

![](/images/articles/afbf49830d82f8/VStackButtons.jpg =350x)
*縦並びの中に横並びの`BoxLayout`*


## コンポーネントを独自に拡張
`Swing`のGUI部品はAPIではコンポーネントと呼ばれており、このコンポーネントを表す`JComponent`を各GUI部品クラスが継承している形になっています。このコンポーネントを継承する各GUI部品クラスを独自に拡張することで宣言的UI化させる目算です。もう少し具体的に説明すると、各GUI部品を継承したクラスを作成し、これに宣言的UI化に適合させるインターフェースを実装させることで、拡張したクラスを共通的に扱えるようにします。

https://github.com/spacehijackle/SwingUI_01/blob/main/app/src/main/java/com/swingui/widget/Widget.java

`Widget`は各GUI部品が必ず実装しなくてはならない、逆に言えば、どんなGUI部品も対応できる基本的なメソッドを定義します。例えば`padding()`はGUI部品の周囲に余白を作るメソッドであり、`frame()`は、そのGUI部品の幅、高さのサイズを決めます。ところでウィジェットという名称は`Linux`等の`UNIX`系OSで稼働する`X Window`でGUI部品を指す単語です。`Flutter`でも同様に呼ばれていますね。概念的にコンポーネント≒ウィジェットであり、コンポーネントは`Swing`のGUI部品を表す一般的な通称、ウィジェットは目指すところの`SwingUI`におけるGUI部品を表すこの記事（あるいは`SwingUI`）での呼称です。いずれにせよ、この`Widget`で定義されているよう、各メソッドが自分自身を返却することがキモです。先にも触れたよう、メソッドチェーンを実現する仕組みになります。

では実際にこの`Widget`を実装するGUI部品を作成します。まずは`JPanel`を拡張する`PanelWT`です。ちなみに末尾の`WT`は`Widget`を表します。

https://github.com/spacehijackle/SwingUI_01/blob/main/app/src/main/java/com/swingui/widget/PanelWT.java

今回の記事では、この`PanelWT`を`BoxLayout`でGUI部品を縦、もしくは横並びにすることが、ひとまずのゴールです。ちなみに`Java`のバージョンは広く適用できるよう、`Java8`にしておきます。

さて、`PanelWT`ですが、`JPanel`を継承し、`Widget`を実装しています。先にもちょっと触れたよう、`JPanel`もGUI部品なので、`Widget`を実装するのです。詳しい実装の話はまた次回以降に回しますが、今回使用するのは`padding(int)`, `frame(int, int)`, `background(UIValue)`になります。これらの実装ですが、順に説明すると、`padding(int)`は`PanelWT`の周囲に指定された数値(px)の余白を確保します。本来は`上部のみ`とか、`左右のみ`に余白を設定可能にするところですが、まずは一番単純なもので実装です。次に`frame(int, int)`ですが、これは`PanelWT`のサイズを固定サイズに設定するものになります。レイアウトに依存するので、必ずしも固定サイズになることを保証するものではありませんが、基本的にコンポーネントのサイズを幅(width)と高さ(height)で固定します。最後に`background(UIValue)`ですが、背景色を指定するものです。`JPanel`は単なる背景だけの存在、と先ほど述べましたが、この背景色を変えることができます。で、肝心の色指定ですが、`Color`というその名の通り、色を表現するクラスを使います。ただし、直接`Color`を指定するのではなく、`UIValue`というクラスを介して渡すようにします。この`UIValue`は次回以降説明します。とりあえず、`background(UIValue)`に色を渡すことで、その指定色に背景が塗られる、というように考えてください。


## おっ、宣言的UIっぽいものが…

ここまでは、まだ宣言的UIの基礎工事みたいなもので、まだその最終的な姿がイメージできないと思いますが、お待たせしました。ようやく宣言的UIの姿を目撃する段に入りました。

この記事の目標は`SwiftUI`みたいな記述をすることで、宣言的UIを目指すことでしたよね。`VStack`,`HStack`で呼び出し、その内部に子コンポーネントを並べるのです。まずは`VStack`で説明します。

https://github.com/spacehijackle/SwingUI_01/blob/main/app/src/main/java/com/swingui/front/layout/VStack.java

`Java`はインスタンスを作成するのに、newキーワードは必須ですが、宣言的UIには似合いません。そこで`static`メソッドにすることで、newキーワード記述を回避します。`public`のメソッド`of()`が２つありますが、基本的にどちらも最後の引数（可変引数）が重要です。`init()`を見てください。子コンポーネントを複数指定することで、`BoxLayout`でレイアウトした`PanelWT`上に指定された子コンポーネントを並べていきます。ここでは縦方向です。
この実装により、`VStack.of(JComponent...)`を呼び出すことでコンポーネントのレイアウトを縦並びにし、そこにGUI部品を並べる、という`SwiftUI`の例で示したようなことが可能になるのです。

https://github.com/spacehijackle/SwingUI_01/blob/main/app/src/main/java/swingui_01/Startup.java

`Startup#buildUpInVertical()`を見てください。`VStack.of()`と`HStack.of()`の組合せで、全体が縦並びで途中で横並び、が実現しています。`VStack`が外側の`PanelWT`であり、`HStack`が内側の`PanelWT`です。`PanelWT`はコンポーネントの継承者なので、`VStack.of(JComponent...)`の引数として`HStack`を指定できるのです。ちなみに`text(String)`は文字列を表示するコンポーネントを返しますが、これはいずれちゃんと宣言的UIのGUI部品として作成することにします。

:::message
以下の実行結果は見直しにより、見た目の変化があります。
詳しくは、記事の最後にある`追記(2025.11.27)`をご覧ください。
:::

![](/images/articles/afbf49830d82f8/VStack.jpg =350x)
*縦並び VStack の中に横並び HStack を実現*

`VStack`, `HStack`それぞれに背景色を指定しています。これにより、それぞれの`PanelWT`の描画範囲が分かりやすくなっていると思います。前者がシアン、後者が黄色で塗り分けています。

また`VStack`に`padding(int)`指定することで周囲に余白が生じていることも確認できるでしょう。加えて`frame(int, int)`により、起動時の`VStack`の幅、高さも実現できているようです（フレームのサイズではないので、ご注意を）。もし、実行できる環境があれば、ウィンドウフレームを広げることで、それに合わせて`PanelWT`のそれぞれの領域が変化することも確認してみてください。ちなみにプロジェクトは`Visual Studio Code`で作りました（gradle使用）。私は元来`Eclipse`をこよなく愛しているのですが、最近の若者はそのようなプログラマを`Eclipseおじさん`と呼ぶそうです。まるで`子供部屋おじさん`と呼ばれているような気がするので、慣れないですがガマンです。

ついでに逆の`HStack`の中に`VStack`もありますので、その画像を乗っけておきます。

![](/images/articles/afbf49830d82f8/HStack.jpg =350x)
*横並び HStack の中に縦並び VStack を実現*

`SwiftUI`の仕様として、コンポーネントは基本的に中心に寄るよう設計されているので、これを踏襲しています。最後に同様な画面を本家の`SwiftUI`と比べてみましょう。

![](/images/articles/afbf49830d82f8/Vertical@Xcode.png =650x)
*本家SwiftUIと比較！*

`SwiftUI`は子コンポーネントのサイズに合わせて領域を調整するのに対し、`SwingUI`の`VStack`は均等に領域を割り当てるので、領域のサイズに違いがあります。これは`BoxLayout`の仕様なので仕方ないと割り切ります。まぁ、そんな感じで`SwiftUI`を目指しながらも、ゆるく目指す`SwingUI`と考えてください。キリがないですからね。


## さいごに
次回以降は他のGUI部品も宣言的UIの仲間に加えていきます。また、`SwiftUI`の`@State`のような、変数を変化させることでGUI部品の見た目を変えたりする機能も紹介するので、ご興味のある方は楽しみにお待ちください。では👋


## 追記 (2025.11.27)
> `SwiftUI`の仕様として、コンポーネントは基本的に中心に寄るよう設計されているので、これを踏襲しています。

`SwiftUI`の仕様に倣って、コンポーネントが中心に寄るように`VStack`,`HStack`を調整したのですが、少々問題が生じました。。。

ウィンドウ・フレームを大きくした時にリスト等、領域が増えた分、大きく見せたいコンポーネントが、そうならなくなりまして… で、最終的に中心に寄せることにこだわることを止めました。

![](/images/articles/afbf49830d82f8/PanelWT-edited_ListBox.jpg =350x)
*ウィンドウの大きさに合わせてリスト表示が大きくなる例（見直し後）*

調整を止めたことで、先にお見せした実行結果は以下のように位置が偏ってしまいますが、別の方法で調整可能な予定ですので、ひとまずはコレでいきたいと思います。

![](/images/articles/afbf49830d82f8/PanelWT-edited_VStack.jpg =350x)
*上部に寄ってしまった実行結果…*

ちなみに現状、`Startup`クラスの`VStack#frame(int, int)`をコメントアウトすると、適切なコンポーネントサイズで、ウィンドウの中心に位置するようになっています（何度も`Github`にコミットしちゃってるので、ならない方は落とし直してください… ごめんクサイ🥸）。

![](/images/articles/afbf49830d82f8/PanelWT-edited2_VStack.jpg =350x)
*ウィンドウ中心にコンポーネントが配置（frame()メソッドはコメントアウト）*

まぁ、見方によっては本家`SwiftUI`の結果により近くなった、とも言えるかも…😅