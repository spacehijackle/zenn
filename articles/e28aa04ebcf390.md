---
title: "Swing 宣言的UI化計画③ ～ボタン人間誕生の巻～"
emoji: "🚀️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "Java", "Swing", "GUI", "宣言的UI", "実験" ]
published: false
---

## 遂にやってきた、ボタン編
これまでは地味なレイアウトの紹介でしたが、今回は`GUI`の代表格(?)であるボタンです。クリックで何か反応がある、って`GUI`を学んだ時に最初に感じる感動だと思うんですよね。そう、今回はそのボタンです。`Swing`ではボタンのコンポーネントは`JButton`なのですが、レイアウトの時と同様、これを`SwingUI`用に拡張します。

まず、`SwingUI`用に拡張する基として`Widget`インターフェース定義がありました。覚えてますか？

https://github.com/spacehijackle/SwingUI_03/blob/main/app/src/main/java/com/swingui/widget/Widget.java

ざっと見てるみると、対象のコンポーネントのサイズを調整したり、背景色を指定の色で塗りつぶしたり… なんていうインターフェースを各コンポーネントで実装するワケですが、今回はその対象が`JButton`なんですね。では早速見てみましょう（今の段階であまり詳しく見ていく必要はありませんよ）。

https://github.com/spacehijackle/SwingUI_03/blob/main/app/src/main/java/com/swingui/widget/button/ButtonWT.java

`JButton`はコンストラクタにテキスト（文字列）を引数に持つもの、アイコンを持つものがあります（テキストとアイコンの両方を持つものもあります）。これらを呼び出すと、指定テキストを表示するボタンだったり、指定アイコンを表示するボタンが作成されます。`JButton`を拡張する`ButtonWT`では、これら２つのコンストラクタを定義します（もちろんテキストとアイコンの両方を表示するボタンが必要であれば、これもコンストラクタとして定義します）。

`ButtonWT`は`Widget`インターフェースを実装するため、例えば`ButtonWT#frame(int, int)`では、ボタンのサイズを固定値として決定し、また背景色を指定する`ButtonWT#background(UIValue<Color>)`では親クラスである`JButton`のメソッドである`JButton#setBackground(Color)`を呼び出し（`UIValue`については次回以降、説明します）、また他のメソッドも同様、必要な分のメソッドを実装していきます。

で、ボタンとして重要な機能、クリックイベントの処理（クリックした時の挙動）を設定する`ButtonWT#onClicked(WTClickListener<ButtonWT>)`を実装します。このクリックイベント処理の設定メソッドですが、他のコンポーネントで共通的な処理ではない、との考え方から`Widget`インターフェースの定義には含めていません。つまり、復習になりますが、`Widget`インターフェースに定義されているメソッドは、各コンポーネントで共通な（コンポーネントであれば定義されてて当然な）機能がまとめてあり、それに外れるものは、各コンポーネントの拡張クラスに任せる、という考え方なんです（まぁクリックイベントは全てのコンポーネントにあっても良い気はしますね… 今後の検討課題です）。

元々`JButton`には`JButton#addActionListener(ActionListener)`というクリックイベントに対応するメソッドがありますが、この引数の`ActionListener`をそのまま利用すると、クリック元のコンポーネントのクラス型が`Object`型になってしまい（クリックしたコンポーネントをイベント処理で利用したい場合はキャストが必要）、使い勝手が良くないので、自前のクリックイベントのリスナーを定義しました。

https://github.com/spacehijackle/SwingUI_03/blob/main/app/src/main/java/com/swingui/event/WTClickListener.java

まぁ、この辺の仕組みは予め知っていないとややこしいところではあるのですが、`ButtonWT`の内部では`ButtonWT#installClickListener()`の処理にあるように、予め`JButton#.addActionListener(ActionListener)`を呼び出し、このイベント処理にて`ButtonWT#onClicked(WTClickListener<ButtonWT>)`の引数で設定されたイベント処理を紐づけているワケです。

クリックイベント処理に関係するメソッドを抽出してみました。

```Java
    // クリック・リスナー
    private WTClickListener<ButtonWT> onClickListener;

    /**
     * クリックイベントを拾うためにリスナーを登録する。
     * ※コンストラクタ経由で呼び出される。
     */
    private void installClickListener()
    {
        addActionListener(v ->
        {
            if(onClickListener != null)
            {
                onClickListener.onClicked(ButtonWT.this);
            }
        });
    }

    /**
     * クリック・リスナーを設定する。
     * 
     * @param listener クリック・リスナー
     * @return 自身のインスタンス
     */
    public ButtonWT onClicked(WTClickListener<ButtonWT> listener)
    {
        this.onClickListener = listener;
        return this;
    }
```

まとめると、ボタンのイベント処理は`JButton#addActionListener(ActionListener)`を利用してクリックされた時のイベント処理が呼び出されるよう設定するのですが、そのイベント処理の定義としては使い勝手の観点から`WTClickListener`を使う、ってことなんです… まぁ、`onClicked(WTClickListener<ButtonWT>)`を呼び出すソースが後ほど出てくるので、それと合わせて見ることで大まかに理解できるかと思います。

ちなみにリスナーとは`聞き耳を立てる`みたいな意味で、クリックのアクションがあるまでジッと待っている、そんなイメージです。要はクリックされた時の処理を予め登録しておく仕組みが`ButtonWT#onClicked()`であり、内部的には`JButton#addActionListener()`である、という感じで捉えるとよいでしょう。


## 宣言的UIに適用
`ButtonWT`を作成しましたが、実際に宣言的UIのソースで呼び出すのは`ButtonWT`をラップした`Button`クラスです。

https://github.com/spacehijackle/SwingUI_03/blob/main/app/src/main/java/com/swingui/front/button/Button.java

こちらは、前回までの`VStack`や`HStack`のようにややこしいものではなく、単純に`ButtonWT`を生成して返すだけですね。

それでは実際にこの`Button.of(...)`を呼び出して画面を作ってみましょう。

![](/images/articles/e28aa04ebcf390/ButtonSample01.jpg =350x)
*作成した`ButtonWT`の各機能を試す！*

```Java
    /**
     * ボタンの様々なパターンをテストする。
     */
    private void testSomeButtonPatterns()
    {
        Frame.of
        (
            "SwingUI Button Sample",

            (f) ->
            {
                f.setResizable(true);  // 画面リサイズ可能
                f.setSize(400, 300);  // 初期画面サイズ指定
            },

            VStack.of
            (
                Spacing.of(24),

                Spacer.fill(),

                HStack.of
                (
                    Button.of(UIManager.getIcon("FileView.directoryIcon"))
                        .frame(30, 30)
                        .self((self) -> self.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR)))
                        .onClicked(self -> showInfoDialog(self, "Folder Icon")),

                    text("Button with Icon")
                ),

                Button.of("Background Color: CYAN")
                    .background(UIValue.of(Color.CYAN))
                    .onClicked(self -> showInfoDialog(self, "Cyan Background")),

                Button.of("Padding with 20px")
                    .padding(20)
                    .onClicked(self -> showInfoDialog(self, "20px padding")),

                Spacer.fill()
            )
        );
    }
```

ちなみに、`VStack`の直後の`Spacing.of(int)`なんですが、前回までは無かった機能です。`SwiftUI`では、縦にコンポーネントを並べていく際、そのコンポーネント間のスペースを`spacing`という引数を使って作っているのですが、これと同じことをしています。ただ、`Java`は名前付き引数の機能がなく、単に`int`型の引数と定義すると、今後発生するかもしれない`of(...)`の別メソッドの引数とバッティングするのが嫌なので（メソッドのオーバーロードでは基本型（原子型）がバッティングしてしまうことはままある）、わざわざ`Spacing`というクラス（単に`int`をラップしただけ）を引数とするようにしました。`SwingUI`では`of(...)`メソッドはオーバーロードが頻繁に発生するので、基本型を避け、専用のクラス型にすることで引数の型バッティング問題に対処した、ということです。メンドウですね。。。

https://github.com/spacehijackle/SwingUI_03/blob/main/app/src/main/java/com/swingui/value/Spacing.java

ちなみに`Spacing`クラスは、その保持する間隔のフィールド変数`int gap`を`public`にして、`VStack`から直接参照できるようにしています。まぁ`private`にして守るほどのものではないかな、という理由です。実際、`VStack`（もしくは`HStack`）からしか参照しないので、値を壊すリスクもないですしね。

改めてボタンの機能を見てみましょう。

最初のアイコン付きボタンでは、以下のように`Button＃of(Icon)`を呼び出し、更に`.frame()`を呼び出すことでボタンサイズを指定しています（メソッドが`Widget`の拡張クラスを返すことでメソッド・チェーンを実現）。

```Java
    HStack.of
    (
        Button.of(UIManager.getIcon("FileView.directoryIcon"))
            .frame(30, 30)
            .self((self) -> self.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR)))
            .onClicked(self -> showInfoDialog(self, "Folder Icon")),

        text("Button with Icon")
    ),
```

重要なのはやはり`.onClick()`ですよね。クリックされるとダイアログを表示する、という処理が設定されているのが分かるでしょう。ラムダ式を使うことで簡易に記述できていますね。ちなみに引数の`self`の実体はクリックが起きたコンポーネント、つまり`ButtonWT`のインスタンスになります。ここではダイアログを表示するために利用しています。

ところで`Widget`インターフェースにも定義されていた`Widget#self(Consumer<T>)`メソッドですが、これを設けた理由は`JButton`に定義された数多くのメソッドに対応する仕組みを`SwingUI`で提供するのはとても大変なので、もう割り切って「ボタンのインスタンスを渡すから、`SwingUI`のボタン機能で足りない機能は直接これから利用して！」ということです。ここではマウスカーソルがボタンの上をホバーすると、手の形のカーソルに変更するようにしています。

```Java
    Button.of("Background Color: CYAN")
        .background(UIValue.of(Color.CYAN))
        .onClicked(self -> showInfoDialog(self, "Cyan Background")),
```
次はボタンの背景色を変える`ButtonWT#.background(UIValue<Color>)`です。繰り返しになりますが、`UIValue`については次回以降説明します。今はシアンを背景色として設定している、と理解してください。

```Java
    Button.of("Padding with 20px")
        .padding(20)
        .onClicked(self -> showInfoDialog(self, "20px padding")),
```
次はパディングです。これも`Widget`インターフェースで定義してあるメソッドです。ボタン内側の余白を作ります。`SwiftUI`では上下左右のそれぞれに余白の値を設定することができますが、`SwingUI`では現状、上下左右に同じ値の余白しか作りません。まぁその内、作るつもりです。

以上で今回作成したボタンのだいたいの機能は確認できたかと思います。


## ボタン人間登場！
前回のレイアウトと今回のボタンの応用編として、少し遊んでみました。ズバリ、**ボタン人間**です。

![](/images/articles/e28aa04ebcf390/ButtonSample02.jpg =350x)
*これがボタン人間！*

`VStack`と`HStack`のレイアウトと、ボタンのサイズ指定機能`.frame(int, int)`で実現できるのですよ。まぁ実用性は皆無ですけど…

```Java
    /**
     * 人型にボタン配置する。
     */
    private void buildHumanBodyButtons()
    {
        Frame.of
        (
            "SwingUI Button Sample",

            (f) ->
            {
                f.setResizable(true);  // 画面リサイズ可能
                f.setSize(400, 400);  // 初期画面サイズ指定
            },

            VStack.of
            (
                Spacer.fill(),

                text("Push the button for each body part below."),

                Spacer.heightOnly(10),

                Button.of("(^o^)")
                    .frame(64, 50)
                    .onClicked(self -> showInfoDialog(self, "Face")),

                HStack.of
                (
                    Button.of("")
                        .frame(40, 80)
                        .onClicked(self -> showInfoDialog(self, "Right Arm")),

                    VStack.of
                    (
                        Button.of("")
                            .frame(100, 50)
                            .onClicked(self -> showInfoDialog(self, "Chest")),

                        Button.of("")
                            .frame(50, 30)
                            .onClicked(self -> showInfoDialog(self, "Stomach"))
                    ),

                    Button.of("")
                        .frame(40, 80)
                        .onClicked(self -> showInfoDialog(self, "Left Arm"))
                ),

                HStack.of
                (
                    Button.of("")
                        .frame(40, 80)
                        .onClicked(self -> showInfoDialog(self, "Right Leg")),

                    Button.of("")
                        .frame(40, 80)
                        .onClicked(self -> showInfoDialog(self, "Left Leg"))
                ),

                Spacer.fill()
            )
        );
    }
```

頭から脚までは`VStack`で縦並びさせ、その途中で「右腕、胴体、左腕」を`HStack`で横並び、更に胴体は`VStack`で胸と腹で縦並び。それぞれのボタンは適切なサイズ設定をしています。そしてボタンクリックで、その部位がダイアログ表示です。

![](/images/articles/e28aa04ebcf390/ButtonSample03.jpg =400x)
*押した部位をダイアログで表示*

## 最後に
今回はボタンを紹介しました。特にボタンクリックの対応処理は呼び出す側は単純でも、呼び出されれる側の実装は少し難しかったかもしれません（逆に`GUI`プログラミングの経験者であれば、それほどでもなかったでしょう）。呼び出し側と呼び出される側を合わせて見ることで理解してもらえたら、と思います。次回はテキストのコンポーネントですかね。興味ある方は楽しみにしててください👋

今回のソース一式は[こちら](https://github.com/spacehijackle/SwingUI_03/tree/main)
